using System;
using System.Diagnostics;
using System.Threading;

namespace EvoApp
{
    // вся логика Эволюции - агрегирована в этом классе. Частично здесь и логика прорисовки юнитов.
    public class App
    {
        public static BiomInfo biomInfo = new BiomInfo ();

        //  информация, которая передается после выполнения каждого шага Эволюции в поток объекта главной формы приложения. Там она отрисовывется в метках
        public AppThreadInfo appThreadInfo = new AppThreadInfo();

        //  население (юниты) со всеми их свойствами
        public Population population = new Population();

        //  мир (Desk) и население (юниты) со всеми их свойствами
        private Desk evoDesk = new Desk();

        public Desk getDesk() {        
            return evoDesk;
        }
        /*
        public void setDesk(Desk desk) {            
            this.evoDesk = desk;
        }*/

        // поток вычисления шага эволюции, запускается по таймеру из потока объекта главной формы приложения.
        static Thread evoThread = null;

        // таймер для замера в потоке расчета шага эволюции. Не путать с таймером запуска (из формы EvoAppForm) расчета шага эволюции - это разные классы и разное назначение.
        // этот измеряет время и имеет тип System.Diagnostics.Stopwatch, а тот - имеет тип System.Windows.Forms.Timer и служит для периодического запуска некоего кода из кода и потока главной формы
        protected Stopwatch watcher = new Stopwatch(); 

        // ******************************************************************************************************
        // вообще говоря, для межпоточных локов лучше использовать ReaderWriterLock. Но с ним нужно разобраться.
        //
        // Собранная по ReaderWriterLock-у информация:
        //
        // static ReaderWriterLock rwEvoLock = new ReaderWriterLock();

        // ReaderWriterLock. AcquireReaderLock()
        // наш поток вызывает этот метод попытаясь захватить ресурс на чтение. Если другие потоки уже захватили ресурс на чтение, то это не помешает нашему потоку прочитать ресурс.
        // Но если этот ресурс уже захвачен другим потоком на запись, или в очереди уже есть поток, ожидающий блокировки на запись - то наш поток будет заблокирован и будет ожидать
        // до тех пор не кончится таймаут (и поток отвалится так и не прочитав ресурс), либо пока все потоки, стоящие перед ним в очереди и ожидающие блокировку записи, - не освободят ресурс.

        // // ReaderWriterLock. AcquireWriterLock()
        // наш поток вызывает этот метод попытаясь захватить ресурс на запись. Если другие потоки уже захватили ресурс на чтение или запись, - то наш поток будет заблокирован и будет ожидать
        // до тех пор не кончится таймаут (и поток отвалится так и не прочитав ресурс), либо пока все потоки, стоящие перед ним в очереди, не освободят ресурс.
        // ******************************************************************************************************

        public App ()
        {
            evoDesk = new Desk();
            appThreadInfo = new AppThreadInfo();
        }

        // ******************************************************************************************************
        // Создание и инициализация ячеек поля Эволюции
        // подготовка отрисовки малой панели и ячеек большой панели - не здесь! (вызывается в конструкторе EvoAppForm(), метод Init()  панелей)
        //
        // Этот метод запускается в потоке асинхронной задачи главной формы приложения
        // Этот поток, и поток App.evoThread, будут конкурировать за ресурс evoDesk.cellTable
        // поэтому evoDesk нужно защитить, и сделаю это с использованием  лока на lockerObjForEvoDesk
        public AppInfo Init()
        {
            watcher.Start();

            int cellCount = this.evoDesk.Init(population);
            population.Generate();

            watcher.Stop();

            Population.appInfo.cellCount = cellCount;
            Population.appInfo.evoInitTime = watcher.ElapsedMilliseconds; ;

            return Population.appInfo;
        }
        
        // ****************************************************************************************               
        // создает и запускает новый поток вычисления шага Эволюции.
        // после выполнения расчета шага, поток завершает свою работу. Для рассчета следующего шага - метод Run () вызывается снова - то еснова будет создан и запущен на выполнение поток.
        public void Run ()
        {
            evoThread = new Thread(App.DoEvoThread);
            evoThread.Start(this);

            Console.WriteLine("! ---------------- расчет шага игры запущен");
        }

        // ****************************************************************************************               
        // Этот метод запускается в потоке App.evoThread этого класса, экземпляр которого создается в потоке главной формы приложения
        public static void DoEvoThread (object this_app_obj)
        {
            App app = (App)this_app_obj;
            app.watcher.Start();

                 app.evoDesk.CalcNextTick();  // вызов этого метода считает шаг эволюции, остальной код - собирает информацию для отображения на форме приложения

            app.watcher.Stop();

            app.appThreadInfo.evoCycleCounter++;
            app.appThreadInfo.evoCycleTime_millisec = app.watcher.ElapsedMilliseconds;
        }

        // ****************************************************************************************               
    }
}
